# pathlib — объектно-ориентированная работа с путями файловой системы

`pathlib` — это встроенная библиотека Python, которая предоставляет объектно-ориентированный интерфейс для работы с путями файловой системы. Вместо строк и функций модуля `os.path`, `pathlib` предлагает классы `Path`, которые инкапсулируют логику работы с путями и делают код более читаемым и кроссплатформенным.

---

## Модуль 1. Контекст и предпосылки

### 1. Ограничения стандартных средств

До появления `pathlib` работа с путями в Python была неудобной:

- **Строковые пути**: пути представлялись обычными строками, что приводило к ошибкам и путанице
- **Разные разделители**: на Windows используется `\`, на Unix — `/`, нужно было помнить об этом
- **Функции разбросаны**: логика работы с путями была в разных модулях (`os`, `os.path`, `shutil`)
- **Нет методов**: нельзя было вызвать метод на пути, нужно было использовать функции
- **Сложная композиция**: объединение путей требовало `os.path.join()` или конкатенации строк

Пример старого подхода:
```python
import os
path = os.path.join('data', 'files', 'document.txt')
if os.path.exists(path):
    with open(path, 'r') as f:
        content = f.read()
```

### 2. Проблема, которую решает инструмент

`pathlib` решает эти проблемы, предоставляя:

- **Объектный интерфейс**: пути — это объекты с методами, а не строки
- **Кроссплатформенность**: автоматически использует правильные разделители
- **Удобная композиция**: оператор `/` для объединения путей
- **Встроенные методы**: `exists()`, `read_text()`, `mkdir()` и т.д. прямо на объекте пути
- **Типизация**: можно использовать `Path` в type hints

### 3. Инженерная / визуальная грамотность

`pathlib` меняет мышление разработчика:

- **От строк к объектам**: пути становятся первоклассными объектами, а не просто строками
- **От функций к методам**: логика работает через методы объекта, что более интуитивно
- **От конкатенации к композиции**: использование оператора `/` делает код более выразительным
- **От условных проверок к методам**: вместо `os.path.exists()` используется `path.exists()`

Это способствует более чистому и декларативному стилю кода.

### 4. Применение в реальных проектах

`pathlib` используется в:

- **CLI-приложениях**: обработка аргументов командной строки с путями
- **Обработке данных**: работа с директориями файлов, логов, конфигов
- **Веб-фреймворках**: управление статическими файлами, шаблонами, загрузками
- **Тестировании**: создание временных директорий, работа с фикстурами
- **Скриптах автоматизации**: поиск файлов, их обработка, организация

---

## Модуль 2. Основные идеи и механизмы

### 5. Центральные объекты и архитектура

Основные классы `pathlib`:

- **`Path`**: универсальный класс для работы с путями (автоматически выбирает `PosixPath` или `WindowsPath`)
- **`PosixPath`**: для Unix-подобных систем (Linux, macOS)
- **`WindowsPath`**: для Windows
- **`PurePath`**: чистый путь без операций с файловой системой (для парсинга)
- **`PurePosixPath` / `PureWindowsPath`**: чистые пути для конкретных ОС

Архитектура основана на наследовании:
```
PurePath
├── PurePosixPath
├── PureWindowsPath
└── Path (наследует PurePath)
    ├── PosixPath
    └── WindowsPath
```

### 6. Ключевые механизмы работы

**Создание путей:**
```python
from pathlib import Path

# Абсолютный путь
p = Path('/home/user/documents')

# Относительный путь
p = Path('data/files')

# Текущая директория
p = Path('.')

# Домашняя директория
p = Path.home()

# Рабочая директория
p = Path.cwd()
```

**Композиция путей (оператор `/`):**
```python
base = Path('data')
file_path = base / 'subfolder' / 'file.txt'
# Результат: data/subfolder/file.txt (или data\subfolder\file.txt на Windows)
```

**Получение компонентов пути:**
```python
p = Path('/home/user/documents/file.txt')

p.name          # 'file.txt' — имя файла
p.stem          # 'file' — имя без расширения
p.suffix        # '.txt' — расширение
p.parent        # Path('/home/user/documents') — родительская директория
p.parts         # ('/', 'home', 'user', 'documents', 'file.txt') — все компоненты
p.drive         # '' на Unix, 'C:' на Windows
p.root          # '/' на Unix, '\' на Windows
```

### 7. Работа со структурированными данными

`pathlib` работает с путями как со структурированными данными:

**Проверка типов:**
```python
p = Path('file.txt')
p.is_file()         # True если это файл
p.is_dir()          # True если это директория
p.is_symlink()      # True если это символическая ссылка
p.exists()          # True если путь существует
```

**Работа с содержимым:**
```python
p = Path('data')
list(p.iterdir())           # Все файлы и папки в директории
list(p.glob('*.txt'))       # Все .txt файлы (не рекурсивно)
list(p.rglob('*.txt'))      # Все .txt файлы (рекурсивно)
```

**Чтение и запись:**
```python
p = Path('file.txt')
content = p.read_text()     # Прочитать весь файл как текст
p.write_text('Hello')       # Записать текст в файл
data = p.read_bytes()       # Прочитать как байты
p.write_bytes(b'data')      # Записать байты
```

### 8. Интерактивность / автоматизация

`pathlib` поддерживает операции с файловой системой:

```python
p = Path('new_folder')
p.mkdir(parents=True, exist_ok=True)    # Создать директорию

p.touch()                               # Создать пустой файл

p.unlink()                              # Удалить файл
p.rmdir()                               # Удалить пустую директорию

p.rename(Path('new_name.txt'))          # Переименовать

p.chmod(0o755)                          # Изменить права доступа

p.stat()                                # Получить информацию о файле
```

### 9. Ошибки и отладка

`pathlib` помогает избежать ошибок:

- **Кроссплатформенность**: автоматически использует правильные разделители
- **Явные методы**: вместо проверки строк используются методы (`is_file()`, `is_dir()`)
- **Исключения**: выбрасывает понятные исключения (`FileNotFoundError`, `IsADirectoryError`)
- **Валидация**: методы проверяют корректность операций

```python
try:
    p = Path('file.txt')
    content = p.read_text()
except FileNotFoundError:
    print(f"Файл {p} не найден")
except IsADirectoryError:
    print(f"{p} — это директория, а не файл")
```

### 10. Организация результата

`pathlib` обеспечивает читаемость и масштабируемость:

- **Цепочки методов**: можно вызывать методы подряд
- **Итерация**: удобно работать с `glob()` и `rglob()`
- **Фильтрация**: легко фильтровать результаты
- **Композиция**: пути легко комбинируются

```python
# Найти все Python файлы в проекте и вывести их размер
project = Path('.')
for py_file in project.rglob('*.py'):
    size = py_file.stat().st_size
    print(f"{py_file}: {size} bytes")
```

---

## Модуль 3. Анализ и оценка

### 11. Сильные стороны

- **Кроссплатформенность**: один код работает на всех ОС
- **Читаемость**: код с `pathlib` более понятен, чем с `os.path`
- **Удобство**: методы прямо на объекте пути
- **Встроенность**: входит в стандартную библиотеку Python
- **Типизация**: хорошо работает с type hints
- **Производительность**: не медленнее, чем `os.path`

### 12. Ограничения и недостатки

- **Не для сетевых путей**: `pathlib` работает только с локальной файловой системой
- **Не для URL**: нельзя использовать для работы с веб-адресами
- **Старый код**: в старых проектах может быть `os.path`, нужна миграция
- **Совместимость**: требует Python 3.4+
- **Производительность на больших директориях**: `glob()` может быть медленным на больших деревьях файлов

### 13. Личное мнение

`pathlib` — это один из лучших примеров улучшения стандартной библиотеки Python. Переход от строк к объектам делает код более безопасным и читаемым. Рекомендую использовать `pathlib` во всех новых проектах вместо `os.path`. Это стандарт де-факто в современном Python-коде.

Оценка: **9/10** — практически идеальное решение для работы с путями, с минимальными ограничениями.
